-- Services
local UserInputService = game:GetService("UserInputService")
local RunService        = game:GetService("RunService")
local Debris            = game:GetService("Debris")
local Players           = game:GetService("Players")
local TweenService      = game:GetService("TweenService")

-- â”€â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local TARGET_KILLER_NAME = "1x1x1x1"
local SHUTDOWN_KEY       = Enum.KeyCode.P
local ALERT_DISTANCE     = 10   -- studs from nearest SURFACE of block

-- Animation IDs
local MASS_INFECTION_IDS = {
    ["131430497821198"]=true, ["99050723653468"]=true, ["104897856211468"]=true,
    ["109777684604906"]=true, ["100592913030351"]=true, ["101101433684051"]=true,
    ["83685305553364"]=true,
}
local ENTANGLEMENT_IDS = {
    ["119181003138006"]=true, ["91237398850193"]=true, ["105026134432828"]=true,
    ["81935774508746"]=true,  ["116787687605496"]=true, ["99030950661794"]=true,
    ["99050723653468"]=true,
}

-- â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local running   = true
local paused    = false
local connections = {}
local LocalPlayer = Players.LocalPlayer
local monitoredCharacters = setmetatable({}, { __mode = "k" })

-- â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function normalizeAssetId(idStr)
    if type(idStr) ~= "string" then return nil end
    return string.match(idStr, "%d+")
end

local function findRootPart(char)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart")
        or char:FindFirstChild("Torso")
        or char:FindFirstChild("UpperTorso")
        or char:FindFirstChild("Head")
end

local function findRotationPart(char)
    if not char then return nil end
    for _, n in ipairs({"HumanoidRootPart","UpperTorso","Torso","Head"}) do
        local p = char:FindFirstChild(n)
        if p and p:IsA("BasePart") then return p end
    end
    return findRootPart(char)
end

local function buildHorizontalCFrame(pos, look)
    local flat = Vector3.new(look.X, 0, look.Z)
    if flat.Magnitude <= 0.001 then flat = Vector3.new(0,0,-1)
    else flat = flat.Unit end
    return CFrame.lookAt(pos, pos + flat, Vector3.new(0,1,0))
end

-- Distance from a world point to nearest SURFACE of an OBB
local function distanceToSurface(part, point)
    if not part or not part.Parent then return math.huge end
    local lp   = part.CFrame:PointToObjectSpace(point)
    local half = part.Size / 2
    local inside = math.abs(lp.X) <= half.X
               and math.abs(lp.Y) <= half.Y
               and math.abs(lp.Z) <= half.Z
    if inside then return 0 end
    local clamped = Vector3.new(
        math.clamp(lp.X, -half.X, half.X),
        math.clamp(lp.Y, -half.Y, half.Y),
        math.clamp(lp.Z, -half.Z, half.Z)
    )
    return (lp - clamped).Magnitude
end

-- Returns "LEFT", "RIGHT", or "FORWARD" based on where block is relative to player
-- Uses nearest surface point instead of center for accurate direction
local function getBlockSide(hrp, block)
    if not block or not block.Parent then return "FORWARD" end

    -- use nearest surface point instead of center
    local lp   = block.CFrame:PointToObjectSpace(hrp.Position)
    local half = block.Size / 2
    local clamped = block.CFrame:PointToWorldSpace(Vector3.new(
        math.clamp(lp.X, -half.X, half.X),
        math.clamp(lp.Y, -half.Y, half.Y),
        math.clamp(lp.Z, -half.Z, half.Z)
    ))

    local toNearest = clamped - hrp.Position
    local dot = toNearest:Dot(hrp.CFrame.RightVector)
    if math.abs(dot) < 1 then return "FORWARD" end
    return dot > 0 and "LEFT" or "RIGHT"
end

-- Is the local player currently the killer?
local function localPlayerIsKiller()
    local char = LocalPlayer.Character
    if not char then return false end
    if char.Name == TARGET_KILLER_NAME then return true end
    local kf = workspace:FindFirstChild("Players")
    if kf then kf = kf:FindFirstChild("Killers") end
    if kf and kf:FindFirstChild(LocalPlayer.Name) then return true end
    return false
end

-- â”€â”€â”€ Shutdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function shutdown()
    if not running then return end
    running = false
    print("[Detector] Shutting down.")
    for _, c in ipairs(connections) do c:Disconnect() end
    connections = {}
end

-- â”€â”€â”€ Scary Fullscreen Alert GUI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function makeAlertGui(animationName, isMassInfection)
    local old = LocalPlayer.PlayerGui:FindFirstChild("KillerAlertGui")
    if old then old:Destroy() end

    local gui = Instance.new("ScreenGui")
    gui.Name = "KillerAlertGui"
    gui.IgnoreGuiInset = true
    gui.ResetOnSpawn = false
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    gui.DisplayOrder = 9999
    gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    -- fullscreen red vignette
    local vignette = Instance.new("Frame")
    vignette.Size = UDim2.fromScale(1,1)
    vignette.BackgroundColor3 = Color3.fromRGB(160,0,0)
    vignette.BackgroundTransparency = 0.5
    vignette.BorderSizePixel = 0
    vignette.Parent = gui

    local vigGrad = Instance.new("UIGradient")
    vigGrad.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0,   Color3.fromRGB(220,0,0)),
        ColorSequenceKeypoint.new(0.45,Color3.fromRGB(0,0,0)),
        ColorSequenceKeypoint.new(1,   Color3.fromRGB(0,0,0)),
    }
    vigGrad.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0,   0.05),
        NumberSequenceKeypoint.new(0.45,0.9),
        NumberSequenceKeypoint.new(1,   1),
    }
    vigGrad.Rotation = 90
    vigGrad.Parent = vignette

    task.spawn(function()
        while vignette.Parent do
            TweenService:Create(vignette, TweenInfo.new(0.2, Enum.EasingStyle.Sine),
                { BackgroundTransparency = 0.15 }):Play()
            task.wait(0.2)
            TweenService:Create(vignette, TweenInfo.new(0.2, Enum.EasingStyle.Sine),
                { BackgroundTransparency = 0.6 }):Play()
            task.wait(0.2)
        end
    end)

    -- scanline texture overlay
    local scan = Instance.new("Frame")
    scan.Size = UDim2.fromScale(1,1)
    scan.BackgroundColor3 = Color3.fromRGB(0,0,0)
    scan.BackgroundTransparency = 0.88
    scan.BorderSizePixel = 0
    scan.Parent = gui
    local sg = Instance.new("UIGradient")
    sg.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.49, 0),
        NumberSequenceKeypoint.new(0.5, 1),
        NumberSequenceKeypoint.new(1, 0),
    }
    sg.Rotation = 90
    sg.Parent = scan

    -- center warning panel
    local container = Instance.new("Frame")
    container.AnchorPoint = Vector2.new(0.5, 0.4)
    container.Position = UDim2.fromScale(0.5, 0.4)
    container.Size = UDim2.fromScale(0, 0)
    container.BackgroundTransparency = 1
    container.Parent = gui

    local panel = Instance.new("Frame")
    panel.AnchorPoint = Vector2.new(0.5, 0.5)
    panel.Position = UDim2.fromScale(0.5, 0.5)
    panel.Size = UDim2.fromScale(1.06, 1.12)
    panel.BackgroundColor3 = Color3.fromRGB(80, 0, 0)
    panel.BackgroundTransparency = 0.2
    panel.BorderSizePixel = 0
    panel.Parent = container
    Instance.new("UICorner", panel).CornerRadius = UDim.new(0, 14)

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 40, 40)
    stroke.Thickness = 3
    stroke.Parent = panel

    task.spawn(function()
        while panel.Parent do
            TweenService:Create(stroke, TweenInfo.new(0.35, Enum.EasingStyle.Sine),
                { Transparency = 0.85 }):Play()
            task.wait(0.35)
            TweenService:Create(stroke, TweenInfo.new(0.35, Enum.EasingStyle.Sine),
                { Transparency = 0 }):Play()
            task.wait(0.35)
        end
    end)

    -- warning icon
    local icon = Instance.new("TextLabel")
    icon.AnchorPoint = Vector2.new(0.5, 0)
    icon.Position = UDim2.fromScale(0.5, 0.02)
    icon.Size = UDim2.fromScale(0.18, 0.36)
    icon.BackgroundTransparency = 1
    icon.Text = "âš "
    icon.Font = Enum.Font.GothamBlack
    icon.TextScaled = true
    icon.TextColor3 = Color3.fromRGB(255, 210, 0)
    icon.TextStrokeTransparency = 0.3
    icon.TextStrokeColor3 = Color3.fromRGB(180, 80, 0)
    icon.Parent = container

    task.spawn(function()
        while icon.Parent do
            TweenService:Create(icon, TweenInfo.new(0.25, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out),
                { TextTransparency = 0.7 }):Play()
            task.wait(0.25)
            TweenService:Create(icon, TweenInfo.new(0.25, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out),
                { TextTransparency = 0 }):Play()
            task.wait(0.25)
        end
    end)

    -- main text
    local warnText = Instance.new("TextLabel")
    warnText.Name = "WarnText"
    warnText.AnchorPoint = Vector2.new(0.5, 0.5)
    warnText.Position = UDim2.fromScale(0.5, 0.54)
    warnText.Size = UDim2.fromScale(0.98, 0.38)
    warnText.BackgroundTransparency = 1
    warnText.Text = isMassInfection and "!! MASS INFECTION !!" or "!! ENTANGLEMENT !!"
    warnText.Font = Enum.Font.GothamBlack
    warnText.TextScaled = true
    warnText.TextColor3 = Color3.fromRGB(255, 255, 255)
    warnText.TextStrokeTransparency = 0
    warnText.TextStrokeColor3 = Color3.fromRGB(255, 0, 0)
    warnText.Parent = container

    local tgrad = Instance.new("UIGradient")
    tgrad.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0,   Color3.fromRGB(255, 80, 80)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1,   Color3.fromRGB(255, 80, 80)),
    }
    tgrad.Parent = warnText

    task.spawn(function()
        local o = 0
        while warnText.Parent do
            o = (o + 0.025) % 1
            tgrad.Offset = Vector2.new(o, 0)
            task.wait(0.03)
        end
    end)

    task.spawn(function()
        local orig = warnText.Position
        while warnText.Parent do
            if math.random() > 0.65 then
                warnText.Position = UDim2.new(
                    orig.X.Scale + (math.random()-0.5)*0.03, 0,
                    orig.Y.Scale + (math.random()-0.5)*0.03, 0)
                task.wait(0.04)
                warnText.Position = orig
            end
            task.wait(0.06)
        end
    end)

    -- sub text
    local sub = Instance.new("TextLabel")
    sub.AnchorPoint = Vector2.new(0.5, 1)
    sub.Position = UDim2.fromScale(0.5, 0.99)
    sub.Size = UDim2.fromScale(0.92, 0.2)
    sub.BackgroundTransparency = 1
    sub.Text = "DANGER ZONE â€” MOVE NOW"
    sub.Font = Enum.Font.Gotham
    sub.TextScaled = true
    sub.TextColor3 = Color3.fromRGB(255, 180, 0)
    sub.TextStrokeTransparency = 0.5
    sub.TextStrokeColor3 = Color3.fromRGB(0,0,0)
    sub.Parent = container

    -- directional arrow (shown below main panel)
    local arrowFrame = Instance.new("Frame")
    arrowFrame.Name = "ArrowFrame"
    arrowFrame.AnchorPoint = Vector2.new(0.5, 0)
    arrowFrame.Position = UDim2.fromScale(0.5, 0.68)
    arrowFrame.Size = UDim2.fromScale(0.45, 0.14)
    arrowFrame.BackgroundColor3 = Color3.fromRGB(20, 0, 0)
    arrowFrame.BackgroundTransparency = 0.3
    arrowFrame.BorderSizePixel = 0
    arrowFrame.Parent = gui
    Instance.new("UICorner", arrowFrame).CornerRadius = UDim.new(0, 10)

    local arrowStroke = Instance.new("UIStroke")
    arrowStroke.Color = Color3.fromRGB(255, 200, 0)
    arrowStroke.Thickness = 2
    arrowStroke.Parent = arrowFrame

    local arrowLabel = Instance.new("TextLabel")
    arrowLabel.Name = "ArrowLabel"
    arrowLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    arrowLabel.Position = UDim2.fromScale(0.5, 0.5)
    arrowLabel.Size = UDim2.fromScale(0.95, 0.85)
    arrowLabel.BackgroundTransparency = 1
    arrowLabel.Text = ""
    arrowLabel.Font = Enum.Font.GothamBlack
    arrowLabel.TextScaled = true
    arrowLabel.TextColor3 = Color3.fromRGB(255, 240, 0)
    arrowLabel.TextStrokeTransparency = 0
    arrowLabel.TextStrokeColor3 = Color3.fromRGB(180, 80, 0)
    arrowLabel.Parent = arrowFrame

    -- arrow bounce animation (slides left or right based on text direction)
    task.spawn(function()
        local base = arrowLabel.Position
        local dir  = 1
        while arrowLabel.Parent do
            local side = arrowLabel.Text or ""
            local shift = 0.045 * dir
            local nx = base.X.Scale + (side:find("LEFT") and -shift or shift)
            TweenService:Create(arrowLabel, TweenInfo.new(0.28, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
                { Position = UDim2.fromScale(nx, base.Y.Scale) }):Play()
            dir = -dir
            task.wait(0.28)
        end
    end)

    -- pop-in entrance
    TweenService:Create(container, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
        { Size = UDim2.fromScale(0.62, 0.24) }):Play()

    return gui, arrowLabel
end

-- â”€â”€â”€ Animation Handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function createAnimationHandler(character)
    return function(animTrack)
        if paused then return end

        local playedId        = normalizeAssetId(animTrack.Animation.AnimationId)
        local isMassInfection = MASS_INFECTION_IDS[playedId] or false
        local isEntanglement  = ENTANGLEMENT_IDS[playedId]   or false
        if not isMassInfection and not isEntanglement then return end

        local animationName = isMassInfection and "MASS INFECTION" or "ENTANGLEMENT"
        print("âœ“ DETECTED:", animationName)

        local cachedRoot     = findRootPart(character)
        local cachedRotation = findRotationPart(character)
        if not cachedRoot then warn("âœ— No root part!"); return end

        local shortSize, longSize, duration
        if isMassInfection then
            shortSize = Vector3.new(10, 5, 11); longSize = Vector3.new(10, 5, 600); duration = 10
        else
            shortSize = Vector3.new(6, 1.8, 5); longSize = Vector3.new(6, 1.8, 600); duration = 4
        end

        local initialCF = buildHorizontalCFrame(
            cachedRoot.Position,
            (cachedRotation and cachedRotation.CFrame.LookVector or Vector3.new(0,0,-1))
        )

        local function makeBlock(name, size)
            local b = Instance.new("Part")
            b.Name = name; b.Size = size; b.Anchored = true
            b.CanCollide = false; b.CanTouch = false; b.CanQuery = false; b.Massless = true
            b.Material = Enum.Material.ForceField
            b.Color = Color3.fromRGB(255,0,0); b.Transparency = 0.5
            b.CFrame = initialCF * CFrame.new(0, 0, -size.Z/2)
            b.Parent = workspace
            Debris:AddItem(b, duration)
            return b
        end

        local shortBlock = makeBlock("KillerShortBlock", shortSize)
        local longBlock  = makeBlock("KillerLongBlock",  longSize)
        print("âœ“ RED blocks spawned | duration:", duration.."s")

        local sound = Instance.new("Sound")
        sound.Name = "KillerAlert"
        sound.SoundId = getcustomasset("forvids/sfx/tetrio/hyperalert.ogg")
        sound.Volume = 6; sound.Looped = false; sound.Parent = workspace

        local soundPlaying = false; local lastPlayed = 0
        local staticBlock = nil; local staticDetected = false
        local staticDetectedAt = 0; local STATIC_DURATION = 5.5

        local alertGui = nil; local arrowLabel = nil; local alertActive = false

        local function showAlert()
            if alertActive then return end
            alertActive = true
            alertGui, arrowLabel = makeAlertGui(animationName, isMassInfection)
        end

        local function hideAlert()
            if not alertActive then return end
            alertActive = false
            if alertGui and alertGui.Parent then alertGui:Destroy(); alertGui = nil; arrowLabel = nil end
        end

        local function updateArrow(side)
            if not arrowLabel then return end
            if side == "LEFT"    then arrowLabel.Text = "â—€â—€  GO LEFT"
            elseif side == "RIGHT" then arrowLabel.Text = "GO RIGHT  â–¶â–¶"
            else arrowLabel.Text = "âš   BACK UP  âš " end
        end

        local function doPlayAlert()
            if not soundPlaying then
                sound:Play(); soundPlaying = true; lastPlayed = os.clock()
            elseif os.clock() - lastPlayed >= 1 then
                sound:Stop(); sound:Play(); lastPlayed = os.clock()
            end
        end

        local function doStopAlert()
            if soundPlaying then sound:Stop() end
            soundPlaying = false; hideAlert()
        end

        local function nearestDist(hrpPos, blocks)
            local min = math.huge
            for _, b in ipairs(blocks) do
                if b and b.Parent then
                    local d = distanceToSurface(b, hrpPos)
                    if d < min then min = d end
                end
            end
            return min
        end

        local function closestBlock(hrpPos, blocks)
            local min, best = math.huge, nil
            for _, b in ipairs(blocks) do
                if b and b.Parent then
                    local d = distanceToSurface(b, hrpPos)
                    if d < min then min = d; best = b end
                end
            end
            return best
        end

        local function checkStaticSpawn()
            if staticDetected then return end
            local map = workspace:FindFirstChild("Map"); if not map then return end
            local ingame = map:FindFirstChild("Ingame"); if not ingame then return end

            local obj, objName
            if isMassInfection then
                obj = ingame:FindFirstChild("Shockwave") or ingame:FindFirstChild("shockwave")
                objName = "SHOCKWAVE"
            else
                obj = ingame:FindFirstChild("Swords"); objName = "SWORDS"
            end
            if not obj then return end

            staticDetected = true; staticDetectedAt = os.clock()
            print("ðŸ”", objName, "FOUND")

            local objPart
            if obj:IsA("Model") then
                objPart = (not isMassInfection and obj:FindFirstChild("Core"))
                    or obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            elseif obj:IsA("BasePart") then objPart = obj end

            if not objPart then warn("âš ï¸ No part in", objName); staticDetected = false; return end

            if isMassInfection then
                local vel = objPart.AssemblyLinearVelocity
                local dir = (vel.Magnitude > 0.1)
                    and Vector3.new(vel.X,0,vel.Z).Unit
                    or  Vector3.new(objPart.CFrame.LookVector.X,0,objPart.CFrame.LookVector.Z).Unit
                local root = findRootPart(character)
                if root then
                    staticBlock = Instance.new("Part")
                    staticBlock.Name = "ShockwaveTrackBlock"; staticBlock.Size = longSize
                    staticBlock.Anchored = true; staticBlock.CanCollide = false
                    staticBlock.Material = Enum.Material.ForceField
                    staticBlock.Color = Color3.fromRGB(0,255,255); staticBlock.Transparency = 0.5
                    local pos = root.Position + dir * (longSize.Z/2)
                    staticBlock.CFrame = CFrame.new(pos, pos+dir)
                    staticBlock.Parent = workspace
                    Debris:AddItem(staticBlock, 10)
                    print("âœ“ SHOCKWAVE cyan block spawned")
                end
            else
                if shortBlock and shortBlock.Parent then shortBlock:Destroy() end
                if longBlock  and longBlock.Parent  then longBlock:Destroy()  end
                staticBlock = Instance.new("Part")
                staticBlock.Name = "SwordsTrackBlock"; staticBlock.Size = longSize
                staticBlock.Anchored = true; staticBlock.CanCollide = false
                staticBlock.Material = Enum.Material.ForceField
                staticBlock.Color = Color3.fromRGB(0,255,255); staticBlock.Transparency = 0.5
                staticBlock.CFrame = objPart.CFrame
                staticBlock.Parent = workspace
                Debris:AddItem(staticBlock, 10)
                print("âœ“ SWORDS cyan block spawned")
            end
        end

        local heartbeat
        heartbeat = RunService.Heartbeat:Connect(function()
            if not character or not character.Parent then
                heartbeat:Disconnect(); doStopAlert()
                if sound and sound.Parent then sound:Destroy() end; return
            end

            -- don't alert if WE are the killer
            if localPlayerIsKiller() then doStopAlert(); return end

            local localChar = LocalPlayer.Character
            local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart")
            if not hrp then doStopAlert(); return end

            if not cachedRoot or not cachedRoot.Parent then
                cachedRoot = findRootPart(character)
                cachedRotation = findRotationPart(character)
            end

            -- update red blocks every frame
            if cachedRoot and cachedRotation then
                local look = cachedRotation.CFrame.LookVector
                local cf   = buildHorizontalCFrame(cachedRoot.Position, look)
                if shortBlock and shortBlock.Parent then
                    shortBlock.CFrame = cf * CFrame.new(0,0,-shortBlock.Size.Z/2) end
                if longBlock and longBlock.Parent then
                    longBlock.CFrame = cf * CFrame.new(0,0,-longBlock.Size.Z/2) end
            end

            checkStaticSpawn()

            -- handle static block expiry
            if staticDetected then
                if not staticBlock or not staticBlock.Parent then
                    staticBlock = nil; staticDetected = false
                elseif os.clock() - staticDetectedAt >= STATIC_DURATION then
                    if staticBlock.Parent then staticBlock:Destroy() end
                    staticBlock = nil; staticDetected = false
                    doStopAlert(); return
                end
            end

            -- build active block list
            local blocks = {}
            if shortBlock  and shortBlock.Parent  then table.insert(blocks, shortBlock)  end
            if longBlock   and longBlock.Parent   then table.insert(blocks, longBlock)   end
            if staticBlock and staticBlock.Parent then table.insert(blocks, staticBlock) end

            if #blocks == 0 then
                heartbeat:Disconnect(); doStopAlert()
                if sound and sound.Parent then sound:Destroy() end; return
            end

            -- nearest SURFACE distance check
            local minDist = nearestDist(hrp.Position, blocks)
            if minDist <= ALERT_DISTANCE then
                local best = closestBlock(hrp.Position, blocks)
                local side = getBlockSide(hrp, best)
                showAlert(); updateArrow(side); doPlayAlert()
            else
                doStopAlert()
            end
        end)
    end
end

-- â”€â”€â”€ Setup character â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function setupCharacter(character)
    if not running then return end
    if character.Name ~= TARGET_KILLER_NAME then return end
    if monitoredCharacters[character] then return end
    monitoredCharacters[character] = true
    print("âœ“ Monitoring killer:", character.Name)

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local handler = createAnimationHandler(character)

    local function hookAnimator(animator)
        table.insert(connections, animator.AnimationPlayed:Connect(handler))
        for _, t in ipairs(animator:GetPlayingAnimationTracks()) do handler(t) end
    end

    local animator = humanoid:FindFirstChildOfClass("Animator")
    if animator then hookAnimator(animator)
    else
        local c
        c = humanoid.ChildAdded:Connect(function(child)
            if child:IsA("Animator") then hookAnimator(child); c:Disconnect() end
        end)
        table.insert(connections, c)
    end
end

-- â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function main()
    print("======================================")
    print("Forsaken Detector â€” Starting")
    print("Target:", TARGET_KILLER_NAME, "| P = shutdown")
    print("Alert distance:", ALERT_DISTANCE, "studs from surface")
    print("======================================")

    local killersFolder
    local wp = workspace:FindFirstChild("Players")
    if wp then killersFolder = wp:FindFirstChild("Killers") end
    if not killersFolder then warn("âœ— workspace.Players.Killers not found!"); return end

    local existing = killersFolder:FindFirstChild(TARGET_KILLER_NAME)
    if existing and existing:IsA("Model") then setupCharacter(existing) end

    table.insert(connections, killersFolder.ChildAdded:Connect(function(child)
        if child.Name == TARGET_KILLER_NAME and child:IsA("Model") then setupCharacter(child) end
    end))

    table.insert(connections, UserInputService.InputBegan:Connect(function(input, gp)
        if not gp and input.KeyCode == SHUTDOWN_KEY then shutdown(); print("[Detector] OFF") end
    end))

    print("âœ“ Running. Press P to stop.")
end

main()
_G.masssword = true

task.spawn(function()
    while running do
        task.wait(1)
        if _G.masssword == false then
            if not paused then paused = true;  print("â¸ï¸ PAUSED")  end
        else
            if paused     then paused = false; print("â–¶ï¸ RESUMED") end
        end
    end
end)
