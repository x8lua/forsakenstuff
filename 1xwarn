-- Services
local UserInputService = game:GetService("UserInputService")
local RunService        = game:GetService("RunService")
local Debris            = game:GetService("Debris")
local Players           = game:GetService("Players")
local TweenService      = game:GetService("TweenService")

-- â”€â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local TARGET_KILLER_NAME  = "1x1x1x1"
local SHUTDOWN_KEY        = Enum.KeyCode.P
local ALERT_DISTANCE      = 10
local MOVING_AWAY_TIMEOUT = 1.0  -- seconds block must be receding before going green

local DECAL_LEFT  = "rbxassetid://124671919099973"
local DECAL_RIGHT = "rbxassetid://97969792683032"
local TWEEN_DUR   = 0.6
local FADE_TIME   = 0.1
local HOLD_TIME   = 0.4
local ARROW_SIZE  = 320
local UI_Y        = 0.62

local MASS_INFECTION_IDS = {
    ["131430497821198"]=true, ["99050723653468"]=true, ["104897856211468"]=true,
    ["109777684604906"]=true, ["100592913030351"]=true, ["101101433684051"]=true,
    ["83685305553364"]=true,
}
local ENTANGLEMENT_IDS = {
    ["119181003138006"]=true, ["91237398850193"]=true, ["105026134432828"]=true,
    ["81935774508746"]=true,  ["116787687605496"]=true, ["99030950661794"]=true,
    ["99050723653468"]=true,
}

-- â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local running   = true
local paused    = false
local connections = {}
local LocalPlayer = Players.LocalPlayer
local monitoredCharacters = setmetatable({}, { __mode = "k" })

-- â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function normalizeAssetId(idStr)
    if type(idStr) ~= "string" then return nil end
    return string.match(idStr, "%d+")
end
local function findRootPart(char)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart")
        or char:FindFirstChild("Torso")
        or char:FindFirstChild("UpperTorso")
        or char:FindFirstChild("Head")
end
local function findRotationPart(char)
    if not char then return nil end
    for _, n in ipairs({"HumanoidRootPart","UpperTorso","Torso","Head"}) do
        local p = char:FindFirstChild(n)
        if p and p:IsA("BasePart") then return p end
    end
    return findRootPart(char)
end
local function buildHorizontalCFrame(pos, look)
    local flat = Vector3.new(look.X, 0, look.Z)
    if flat.Magnitude <= 0.001 then flat = Vector3.new(0,0,-1)
    else flat = flat.Unit end
    return CFrame.lookAt(pos, pos + flat, Vector3.new(0,1,0))
end
local function distanceToSurface(part, point)
    if not part or not part.Parent then return math.huge end
    local lp   = part.CFrame:PointToObjectSpace(point)
    local half = part.Size / 2
    local inside = math.abs(lp.X)<=half.X and math.abs(lp.Y)<=half.Y and math.abs(lp.Z)<=half.Z
    if inside then return 0 end
    local clamped = Vector3.new(
        math.clamp(lp.X,-half.X,half.X),
        math.clamp(lp.Y,-half.Y,half.Y),
        math.clamp(lp.Z,-half.Z,half.Z))
    return (lp-clamped).Magnitude
end
local function getEscapeDirection(hrp, block)
    if not block or not block.Parent then return "LEFT" end
    local camRight = workspace.CurrentCamera.CFrame.RightVector
    local localPos = block.CFrame:PointToObjectSpace(hrp.Position)
    local escapeDir = localPos.X <= 0 and -block.CFrame.RightVector or block.CFrame.RightVector
    return escapeDir:Dot(camRight) > 0 and "RIGHT" or "LEFT"
end
local function localPlayerIsKiller()
    local char = LocalPlayer.Character
    if not char then return false end
    if char.Name == TARGET_KILLER_NAME then return true end
    local kf = workspace:FindFirstChild("Players")
    if kf then kf = kf:FindFirstChild("Killers") end
    if kf and kf:FindFirstChild(LocalPlayer.Name) then return true end
    return false
end
local function setBlockColor(block, color)
    if block and block.Parent then block.Color = color end
end

-- â”€â”€â”€ Shutdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function shutdown()
    if not running then return end
    running = false
    print("[Detector] Shutting down.")
    for _, c in ipairs(connections) do c:Disconnect() end
    connections = {}
end

-- â”€â”€â”€ Alert UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function buildAlertUI()
    local cam    = workspace.CurrentCamera
    local vp     = cam.ViewportSize
    local SW, SH = vp.X, vp.Y
    local CX     = SW / 2
    local textPxY  = SH * UI_Y
    local arrowPxY = textPxY - (ARROW_SIZE / 2) - 10

    local drawText = Drawing.new("Text")
    drawText.Size = 90; drawText.Font = Drawing.Fonts.UI
    drawText.Center = true; drawText.Outline = true
    drawText.OutlineColor = Color3.fromRGB(80,0,0)
    drawText.Color = Color3.fromRGB(220,30,30)
    drawText.Position = Vector2.new(CX, textPxY)
    drawText.Transparency = 1; drawText.Visible = true; drawText.Text = ""

    local drawShadow = Drawing.new("Text")
    drawShadow.Size = 90; drawShadow.Font = Drawing.Fonts.UI
    drawShadow.Center = true; drawShadow.Outline = false
    drawShadow.Color = Color3.fromRGB(10,0,0)
    drawShadow.Position = Vector2.new(CX+3, textPxY+4)
    drawShadow.Transparency = 1; drawShadow.Visible = true; drawShadow.Text = ""

    local gui = Instance.new("ScreenGui")
    gui.Name = "GoDirectionUI"; gui.ResetOnSpawn = false
    gui.IgnoreGuiInset = true
    gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    local img = Instance.new("ImageLabel")
    img.BackgroundTransparency = 1
    img.AnchorPoint = Vector2.new(0.5,0.5)
    img.Position = UDim2.new(0,CX,0,arrowPxY)
    img.Size = UDim2.fromOffset(ARROW_SIZE,ARROW_SIZE)
    img.ImageTransparency = 1
    img.ImageColor3 = Color3.fromRGB(200,40,40)
    img.ScaleType = Enum.ScaleType.Fit
    img.ZIndex = 2; img.Parent = gui

    local bar = Instance.new("Frame")
    bar.BackgroundColor3 = Color3.fromRGB(5,0,0)
    bar.BackgroundTransparency = 1; bar.BorderSizePixel = 0
    bar.AnchorPoint = Vector2.new(0.5,0.5)
    bar.Position = UDim2.new(0.5,0,UI_Y,0)
    bar.Size = UDim2.new(1,0,0,ARROW_SIZE+80)
    bar.ZIndex = 1; bar.Visible = false; bar.Parent = gui

    local uiGrad = Instance.new("UIGradient")
    uiGrad.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0,   Color3.fromRGB(0,0,0)),
        ColorSequenceKeypoint.new(0.2, Color3.fromRGB(8,0,0)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(15,0,0)),
        ColorSequenceKeypoint.new(0.8, Color3.fromRGB(8,0,0)),
        ColorSequenceKeypoint.new(1,   Color3.fromRGB(0,0,0)),
    })
    uiGrad.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0,    1),
        NumberSequenceKeypoint.new(0.15, 0.3),
        NumberSequenceKeypoint.new(0.5,  0),
        NumberSequenceKeypoint.new(0.85, 0.3),
        NumberSequenceKeypoint.new(1,    1),
    })
    uiGrad.Parent = bar

    local alertSound = Instance.new("Sound")
    alertSound.Name = "DamageAlert"
    alertSound.SoundId = getcustomasset("forvids/sfx/tetrio/damage_alert.ogg")
    alertSound.Volume = 5; alertSound.Looped = false; alertSound.Parent = workspace

    -- internal
    local slideInfo   = TweenInfo.new(TWEEN_DUR, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
    local fadeInInfo  = TweenInfo.new(FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local fadeOutInfo = TweenInfo.new(FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
    local barFadeIn   = TweenInfo.new(FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local barFadeOut  = TweenInfo.new(FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

    local currentDir  = "LEFT"
    local loopRunning = false
    local loopThread  = nil
    local soundPlaying = false
    local lastSoundT   = 0

    local activeFade = nil
    local function fadeText(fromT, toT, dur)
        if activeFade then task.cancel(activeFade) end
        activeFade = task.spawn(function()
            local elapsed, step = 0, 1/60
            while elapsed < dur do
                elapsed += step
                local v = fromT + (toT-fromT)*math.clamp(elapsed/dur,0,1)
                drawText.Transparency   = v
                drawShadow.Transparency = v
                task.wait(step)
            end
            drawText.Transparency   = toT
            drawShadow.Transparency = toT
        end)
    end

    local function glitch()
        task.spawn(function()
            for _ = 1,3 do
                local ox,oy = math.random(-6,6), math.random(-3,3)
                drawText.Position   = Vector2.new(CX+ox, textPxY+oy)
                drawShadow.Position = Vector2.new(CX+ox+3, textPxY+oy+4)
                task.wait(0.04)
            end
            drawText.Position   = Vector2.new(CX, textPxY)
            drawShadow.Position = Vector2.new(CX+3, textPxY+4)
        end)
    end

    local function clearVisuals()
        drawText.Text = ""; drawShadow.Text = ""
        drawText.Transparency = 1; drawShadow.Transparency = 1
        bar.Visible = false; img.ImageTransparency = 1
    end

    -- single cycle â€” interruptible by direction change
    local function runOneCycle(dir)
        local goLeft    = (dir == "LEFT")
        local edgePx    = goLeft and (SW*0.05) or (SW*0.95)
        local centerPos = UDim2.new(0,CX,0,arrowPxY)
        local destPos   = UDim2.new(0,edgePx,0,arrowPxY)

        local label = goLeft and "GO LEFT" or "GO RIGHT"
        drawText.Text = label; drawShadow.Text = label
        img.Image = goLeft and DECAL_LEFT or DECAL_RIGHT

        -- reset to center (timeline = 0)
        img.Position = centerPos; img.ImageTransparency = 1
        bar.BackgroundTransparency = 1; bar.Visible = true
        drawText.Transparency = 0; drawShadow.Transparency = 0

        -- kick off slide + fade in
        fadeText(0,1,FADE_TIME)
        TweenService:Create(bar,  barFadeIn,  {BackgroundTransparency=0.3}):Play()
        TweenService:Create(img,  slideInfo,  {Position=destPos}):Play()
        TweenService:Create(img,  fadeInInfo, {ImageTransparency=0}):Play()
        glitch()

        -- wait TWEEN_DUR but break early if direction changed
        local elapsed = 0
        local totalWait = TWEEN_DUR + HOLD_TIME
        while elapsed < totalWait do
            task.wait(0.05)
            elapsed += 0.05
            -- â”€â”€ INTERRUPT: direction changed or loop stopped â”€â”€
            if not loopRunning or currentDir ~= dir then
                break
            end
        end

        -- fade out + reset (timeline back to 0)
        fadeText(1,0,FADE_TIME)
        TweenService:Create(bar, barFadeOut,  {BackgroundTransparency=1}):Play()
        TweenService:Create(img, fadeOutInfo, {ImageTransparency=1}):Play()
        task.wait(FADE_TIME)

        bar.Visible = false
        img.Position = centerPos  -- back to center = timeline 0
    end

    local ui = {}

    function ui.show(dir)
        -- if direction changed mid-cycle, update and the running cycle will interrupt itself
        local dirChanged = currentDir ~= dir
        currentDir = dir

        local now = os.clock()
        if not soundPlaying or now - lastSoundT >= 1.5 then
            alertSound:Stop(); alertSound:Play()
            soundPlaying = true; lastSoundT = now
        end

        if loopRunning then
            -- direction change already handled by runOneCycle polling currentDir
            return
        end

        loopRunning = true
        loopThread = task.spawn(function()
            while loopRunning do
                runOneCycle(currentDir)
                if not loopRunning then break end
                task.wait(0.03)
            end
            clearVisuals()
        end)
    end

    function ui.hide()
        if not loopRunning then return end
        loopRunning = false
        alertSound:Stop(); soundPlaying = false
        if loopThread then task.cancel(loopThread); loopThread = nil end
        clearVisuals()
    end

    function ui.destroy()
        ui.hide()
        drawText:Remove(); drawShadow:Remove()
        gui:Destroy()
        if alertSound and alertSound.Parent then alertSound:Destroy() end
    end

    function ui.updateDir(dir)
        currentDir = dir
    end

    return ui
end

-- â”€â”€â”€ Animation Handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function createAnimationHandler(character)
    return function(animTrack)
        if paused then return end
        local playedId        = normalizeAssetId(animTrack.Animation.AnimationId)
        local isMassInfection = MASS_INFECTION_IDS[playedId] or false
        local isEntanglement  = ENTANGLEMENT_IDS[playedId]   or false
        if not isMassInfection and not isEntanglement then return end

        local animationName = isMassInfection and "MASS INFECTION" or "ENTANGLEMENT"
        print("âœ“ DETECTED:", animationName)

        local cachedRoot     = findRootPart(character)
        local cachedRotation = findRotationPart(character)
        if not cachedRoot then warn("âœ— No root part!"); return end

        local shortSize, longSize, duration
        if isMassInfection then
            shortSize=Vector3.new(10,5,11); longSize=Vector3.new(10,5,600); duration=10
        else
            shortSize=Vector3.new(6,1.8,5); longSize=Vector3.new(6,1.8,600); duration=4
        end

        local initialCF = buildHorizontalCFrame(
            cachedRoot.Position,
            (cachedRotation and cachedRotation.CFrame.LookVector or Vector3.new(0,0,-1))
        )
        local function makeBlock(name, size)
            local b = Instance.new("Part")
            b.Name=name; b.Size=size; b.Anchored=true
            b.CanCollide=false; b.CanTouch=false; b.CanQuery=false; b.Massless=true
            b.Material=Enum.Material.ForceField
            b.Color=Color3.fromRGB(255,0,0); b.Transparency=0.5
            b.CFrame=initialCF*CFrame.new(0,0,-size.Z/2)
            b.Parent=workspace; Debris:AddItem(b,duration)
            return b
        end

        local shortBlock = makeBlock("KillerShortBlock", shortSize)
        local longBlock  = makeBlock("KillerLongBlock",  longSize)
        print("âœ“ RED blocks | duration:", duration.."s")

        local hyperSound = Instance.new("Sound")
        hyperSound.SoundId = getcustomasset("forvids/sfx/tetrio/hyperalert.ogg")
        hyperSound.Volume = 6; hyperSound.Looped = false; hyperSound.Parent = workspace
        hyperSound:Play(); Debris:AddItem(hyperSound, 5)

        local alertUI = buildAlertUI()

        local staticBlock=nil; local staticDetected=false
        local staticDetectedAt=0; local STATIC_DURATION=5.5

        -- â”€â”€ moving-away tracking per block â”€â”€
        -- key = block reference, value = { lastDist, recedingStartTime, isGreen }
        local blockState = {}
        local function getBlockState(b)
            if not blockState[b] then
                blockState[b] = { lastDist = math.huge, recedingStart = nil, recedingSnapDist = nil, isGreen = false }
            end
            return blockState[b]
        end

        local function checkStaticSpawn()
            if staticDetected then return end
            local map=workspace:FindFirstChild("Map"); if not map then return end
            local ingame=map:FindFirstChild("Ingame"); if not ingame then return end
            local obj, objName
            if isMassInfection then
                obj=ingame:FindFirstChild("Shockwave") or ingame:FindFirstChild("shockwave")
                objName="SHOCKWAVE"
            else obj=ingame:FindFirstChild("Swords"); objName="SWORDS" end
            if not obj then return end
            staticDetected=true; staticDetectedAt=os.clock()
            print("ðŸ”", objName, "FOUND")
            local objPart
            if obj:IsA("Model") then
                objPart=(not isMassInfection and obj:FindFirstChild("Core"))
                    or obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            elseif obj:IsA("BasePart") then objPart=obj end
            if not objPart then warn("âš ï¸ No part in",objName); staticDetected=false; return end
            if isMassInfection then
                local vel=objPart.AssemblyLinearVelocity
                local dir=(vel.Magnitude>0.1)
                    and Vector3.new(vel.X,0,vel.Z).Unit
                    or  Vector3.new(objPart.CFrame.LookVector.X,0,objPart.CFrame.LookVector.Z).Unit
                local root=findRootPart(character)
                if root then
                    staticBlock=Instance.new("Part")
                    staticBlock.Name="ShockwaveTrackBlock"; staticBlock.Size=longSize
                    staticBlock.Anchored=true; staticBlock.CanCollide=false
                    staticBlock.Material=Enum.Material.ForceField
                    staticBlock.Color=Color3.fromRGB(0,255,255); staticBlock.Transparency=0.5
                    local pos=root.Position+dir*(longSize.Z/2)
                    staticBlock.CFrame=CFrame.new(pos,pos+dir)
                    staticBlock.Parent=workspace; Debris:AddItem(staticBlock,10)
                    print("âœ“ SHOCKWAVE cyan block")
                end
            else
                if shortBlock and shortBlock.Parent then shortBlock:Destroy() end
                if longBlock  and longBlock.Parent  then longBlock:Destroy()  end
                staticBlock=Instance.new("Part")
                staticBlock.Name="SwordsTrackBlock"; staticBlock.Size=longSize
                staticBlock.Anchored=true; staticBlock.CanCollide=false
                staticBlock.Material=Enum.Material.ForceField
                staticBlock.Color=Color3.fromRGB(0,255,255); staticBlock.Transparency=0.5
                staticBlock.CFrame=objPart.CFrame
                staticBlock.Parent=workspace; Debris:AddItem(staticBlock,10)
                print("âœ“ SWORDS cyan block")
            end
        end

        local heartbeat
        heartbeat = RunService.Heartbeat:Connect(function()
            if not character or not character.Parent then
                heartbeat:Disconnect(); alertUI.destroy(); return
            end
            if localPlayerIsKiller() then alertUI.hide(); return end

            local localChar = LocalPlayer.Character
            local hrp = localChar and localChar:FindFirstChild("HumanoidRootPart")
            if not hrp then alertUI.hide(); return end

            if not cachedRoot or not cachedRoot.Parent then
                cachedRoot=findRootPart(character)
                cachedRotation=findRotationPart(character)
            end

            if cachedRoot and cachedRotation then
                local look=cachedRotation.CFrame.LookVector
                local cf=buildHorizontalCFrame(cachedRoot.Position, look)
                if shortBlock and shortBlock.Parent then
                    shortBlock.CFrame=cf*CFrame.new(0,0,-shortBlock.Size.Z/2) end
                if longBlock and longBlock.Parent then
                    longBlock.CFrame=cf*CFrame.new(0,0,-longBlock.Size.Z/2) end
            end

            checkStaticSpawn()

            if staticDetected then
                if not staticBlock or not staticBlock.Parent then
                    staticBlock=nil; staticDetected=false
                elseif os.clock()-staticDetectedAt >= STATIC_DURATION then
                    if staticBlock.Parent then staticBlock:Destroy() end
                    staticBlock=nil; staticDetected=false
                    alertUI.hide(); return
                end
            end

            local blocks = {}
            if shortBlock  and shortBlock.Parent  then table.insert(blocks, shortBlock)  end
            if longBlock   and longBlock.Parent   then table.insert(blocks, longBlock)   end
            if staticBlock and staticBlock.Parent then table.insert(blocks, staticBlock) end

            if #blocks == 0 then
                heartbeat:Disconnect(); alertUI.destroy(); return
            end

            local now = os.clock()

            -- â”€â”€ update moving-away state for each block â”€â”€
            -- uses CENTER-to-CENTER distance so it works even when player is inside block
            -- snapshots distance at start of receding window to avoid noise resets
            for _, b in ipairs(blocks) do
                local s    = getBlockState(b)
                local dist = (b.Position - hrp.Position).Magnitude

                if not s.recedingStart then
                    -- not yet tracking â€” check if it just started moving away
                    if s.lastDist < math.huge and dist > s.lastDist + 0.05 then
                        s.recedingStart    = now
                        s.recedingSnapDist = s.lastDist  -- snapshot distance at start
                    end
                else
                    -- currently tracking receding
                    local elapsed = now - s.recedingStart
                    if dist < s.recedingSnapDist and not s.isGreen then
                        -- came back closer before 1s was up â†’ reset timer (only if not green yet)
                        s.recedingStart    = nil
                        s.recedingSnapDist = nil
                    elseif elapsed >= MOVING_AWAY_TIMEOUT and not s.isGreen then
                        -- been moving away for 1s and never came back â†’ green
                        s.isGreen = true
                        setBlockColor(b, Color3.fromRGB(0, 200, 80))
                        print("âœ… Block receding 1s â†’ GREEN")
                    end
                end

                s.lastDist = dist
            end

            -- â”€â”€ find nearest NON-green block â”€â”€
            local minDist, closestB = math.huge, nil
            for _, b in ipairs(blocks) do
                local s = getBlockState(b)
                if not s.isGreen then
                    local d = distanceToSurface(b, hrp.Position)
                    if d < minDist then minDist=d; closestB=b end
                end
            end

            if closestB and minDist <= ALERT_DISTANCE then
                local dir = getEscapeDirection(hrp, closestB)
                alertUI.updateDir(dir)
                alertUI.show(dir)
            else
                alertUI.hide()
            end
        end)
    end
end

-- â”€â”€â”€ Setup character â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function setupCharacter(character)
    if not running then return end
    if character.Name ~= TARGET_KILLER_NAME then return end
    if monitoredCharacters[character] then return end
    monitoredCharacters[character] = true
    print("âœ“ Monitoring killer:", character.Name)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local handler = createAnimationHandler(character)
    local function hookAnimator(animator)
        table.insert(connections, animator.AnimationPlayed:Connect(handler))
        for _, t in ipairs(animator:GetPlayingAnimationTracks()) do handler(t) end
    end
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if animator then hookAnimator(animator)
    else
        local c
        c = humanoid.ChildAdded:Connect(function(child)
            if child:IsA("Animator") then hookAnimator(child); c:Disconnect() end
        end)
        table.insert(connections, c)
    end
end

-- â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function main()
    print("======================================")
    print("Forsaken Detector â€” Starting")
    print("Target:", TARGET_KILLER_NAME, "| P = shutdown")
    print("Alert distance:", ALERT_DISTANCE, "studs | Moving-away timeout:", MOVING_AWAY_TIMEOUT.."s")
    print("======================================")
    local killersFolder
    local wp = workspace:FindFirstChild("Players")
    if wp then killersFolder = wp:FindFirstChild("Killers") end
    if not killersFolder then warn("âœ— workspace.Players.Killers not found!"); return end
    local existing = killersFolder:FindFirstChild(TARGET_KILLER_NAME)
    if existing and existing:IsA("Model") then setupCharacter(existing) end
    table.insert(connections, killersFolder.ChildAdded:Connect(function(child)
        if child.Name == TARGET_KILLER_NAME and child:IsA("Model") then setupCharacter(child) end
    end))
    table.insert(connections, UserInputService.InputBegan:Connect(function(input, gp)
        if not gp and input.KeyCode == SHUTDOWN_KEY then shutdown(); print("[Detector] OFF") end
    end))
    print("âœ“ Running. Press P to stop.")
end

main()
_G.masssword = true

task.spawn(function()
    while running do
        task.wait(1)
        if _G.masssword == false then
            if not paused then paused=true;  print("â¸ï¸ PAUSED")  end
        else
            if paused     then paused=false; print("â–¶ï¸ RESUMED") end
        end
    end
end)
