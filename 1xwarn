-- Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Players = game:GetService("Players")

-- Configuration
local TARGET_KILLER_NAME = "1x1x1x1"

-- Animation IDs to detect
local MASS_INFECTION_IDS = {
    ["131430497821198"] = true,
    ["99050723653468"] = true,
    ["104897856211468"] = true,
    ["109777684604906"] = true,
    ["100592913030351"] = true,
    ["101101433684051"] = true,
    ["83685305553364"] = true,
}

local ENTANGLEMENT_IDS = {
    ["119181003138006"] = true,
    ["91237398850193"] = true,
    ["105026134432828"] = true,
    ["81935774508746"] = true,
    ["116787687605496"] = true,
    ["99030950661794"] = true,
    ["99050723653468"] = true,
}

local SHUTDOWN_KEY = Enum.KeyCode.P
local DEBUG = true -- Set to false to disable detailed debug output

-- State
local running = true
local paused = false
local connections = {}
local LocalPlayer = Players.LocalPlayer
local monitoredCharacters = setmetatable({}, { __mode = "k" })

-- Helper: get table keys as a string
local function getKeysString(tbl)
    local keys = {}
    for key, _ in pairs(tbl) do
        table.insert(keys, tostring(key))
    end
    return table.concat(keys, ", ")
end

-- Main shutdown function
local function shutdown()
    if not running then return end
    running = false
    
    print("Animation detection script shutting down.")
    
    for _, connection in ipairs(connections) do
        connection:Disconnect()
    end
    connections = {} -- Clear connections table
end

-- Debug print helper
local function debugPrint(...)
    if DEBUG then
        print("[DEBUG]", ...)
    end
end

-- Normalize asset id string to its numeric id
local function normalizeAssetId(idStr)
    if type(idStr) ~= "string" then return nil end
    return string.match(idStr, "%d+")
end

-- Helper: find character root part
local function findRootPart(character)
    if not character then return nil end
    
    -- Try common root part names
    local root = character:FindFirstChild("HumanoidRootPart") 
                or character:FindFirstChild("Torso") 
                or character:FindFirstChild("UpperTorso")
                or character:FindFirstChild("Head")
    
    if root then
        debugPrint("  Found root part:", root.Name)
        return root
    end
    
    -- If no standard root found, look for any BasePart that could serve as anchor
    for _, child in ipairs(character:GetChildren()) do
        if child:IsA("BasePart") then
            debugPrint("  Using fallback root part:", child.Name)
            return child
        end
    end
    
    return nil
end

-- Function factory: creates an animation handler for a specific character
local function createAnimationHandler(character)
    return function(animationTrack)
        -- Check if script is paused
        if paused then
            debugPrint("Script is paused, ignoring animation")
            return
        end
        
        debugPrint("Animation played detected")
        debugPrint("  Animation object:", animationTrack.Animation)
        debugPrint("  Animation ID:", animationTrack.Animation.AnimationId)
        
        local playedId = normalizeAssetId(animationTrack.Animation.AnimationId)
        debugPrint("  Normalized ID:", playedId)
        
        local isMassInfection = MASS_INFECTION_IDS[playedId] or false
        local isEntanglement = ENTANGLEMENT_IDS[playedId] or false
        
        if isMassInfection or isEntanglement then
            local animationName = isMassInfection and "MASS INFECTION" or "ENTANGLEMENT"
            print("‚úì TARGET ANIMATION DETECTED:", animationName)
            print("  Character:", character.Name)
            print("  Character path:", character:GetFullName())
            
            local root = findRootPart(character)
            debugPrint("  Root part search result:", root)
            
            if not root then 
                warn("‚úó Cannot create blocks: No root part found!")
                debugPrint("  Character children:")
                for _, child in ipairs(character:GetChildren()) do
                    debugPrint("    -", child.Name, "(" .. child.ClassName .. ")")
                end
                return 
            end
            
            -- Compute forward (flattened on XZ plane)
            local look = root.CFrame.LookVector
            debugPrint("  Root position:", root.Position)
            debugPrint("  Root LookVector:", look)
            
            local flatLook = Vector3.new(look.X, 0, look.Z)
            debugPrint("  Flattened LookVector:", flatLook)
            debugPrint("  Flattened magnitude:", flatLook.Magnitude)
            
            if flatLook.Magnitude > 0 then
                flatLook = flatLook.Unit
            else
                flatLook = look
            end
            debugPrint("  Final forward direction:", flatLook)
            
            -- Determine block sizes and duration based on animation type
            local shortSize, longSize, duration
            if isMassInfection then
                shortSize = Vector3.new(10, 5, 11)
                longSize = Vector3.new(10, 5, 600)
                duration = 10
            else -- Entanglement
                shortSize = Vector3.new(6, 1.8, 5)
                longSize = Vector3.new(6, 1.8, 600)
                duration = 4
            end
            
            -- Create a short block in front of killer
            local shortBlock = Instance.new("Part")
            shortBlock.Name = "KillerShortBlock"
            shortBlock.Size = shortSize
            shortBlock.Anchored = false
            shortBlock.CanCollide = false
            shortBlock.CanTouch = false
            shortBlock.CanQuery = false
            shortBlock.Massless = true
            shortBlock.Material = Enum.Material.ForceField
            shortBlock.Color = Color3.fromRGB(255, 0, 0)
            shortBlock.Transparency = 0.5
            shortBlock.CFrame = root.CFrame * CFrame.new(0, 0, -shortSize.Z / 2)
            shortBlock.Parent = workspace

            local shortWeld = Instance.new("WeldConstraint")
            shortWeld.Part0 = shortBlock
            shortWeld.Part1 = root
            shortWeld.Parent = shortBlock
            
            print("‚úì Created SHORT block (" .. shortSize.X .. "x" .. shortSize.Y .. "x" .. shortSize.Z .. ") - Duration: " .. duration .. "s")
            debugPrint("  Short block position:", shortBlock.Position)
            debugPrint("  Short block CFrame:", shortBlock.CFrame)
            debugPrint("  Short block parent:", shortBlock.Parent)
            
            Debris:AddItem(shortBlock, duration)
            
            -- Create a long block facing killer forward
            local longBlock = Instance.new("Part")
            longBlock.Name = "KillerLongBlock"
            longBlock.Size = longSize
            longBlock.Anchored = false
            longBlock.CanCollide = false
            longBlock.CanTouch = false
            longBlock.CanQuery = false
            longBlock.Massless = true
            longBlock.Material = Enum.Material.ForceField
            longBlock.Color = Color3.fromRGB(255, 0, 0)
            longBlock.Transparency = 0.5
            longBlock.CFrame = root.CFrame * CFrame.new(0, 0, -longSize.Z / 2)
            longBlock.Parent = workspace

            local longWeld = Instance.new("WeldConstraint")
            longWeld.Part0 = longBlock
            longWeld.Part1 = root
            longWeld.Parent = longBlock
            
            print("‚úì Created LONG block (" .. longSize.X .. "x" .. longSize.Y .. "x" .. longSize.Z .. ") - Duration: " .. duration .. "s")
            debugPrint("  Long block position:", longBlock.Position)
            debugPrint("  Long block CFrame:", longBlock.CFrame)
            debugPrint("  Long block parent:", longBlock.Parent)
            
            Debris:AddItem(longBlock, duration)
            
            -- Sound that plays while local player is inside either block
            local sound = Instance.new("Sound")
            sound.Name = "AlertSound"
            sound.SoundId = getcustomasset("forvids/sfx/tetrio/hyperalert.ogg")
            sound.Volume = 6
            sound.Looped = false
            sound.Parent = longBlock
            
            local soundPlaying = false
            local lastPlayed = 0
            
            -- Warning GUI that shows when local player is inside either block
            local warnGui = nil
            local function createWarningGui()
                if warnGui and warnGui.Parent then return end

                local TweenService = game:GetService("TweenService")

                -- Create the main ScreenGui
                local gui = Instance.new("ScreenGui")
                gui.Name = animationName .. "Warn"
                gui.IgnoreGuiInset = true
                gui.ResetOnSpawn = false
                gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
                gui.DisplayOrder = 999
                gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

                -- Center container for the warning text (compact size for visibility)
                local centerContainer = Instance.new("Frame")
                centerContainer.Name = "CenterContainer"
                centerContainer.AnchorPoint = Vector2.new(0.5, 0.5)
                centerContainer.Position = UDim2.fromScale(0.5, 0.5)
                centerContainer.Size = UDim2.fromScale(0.6, 0.15)
                centerContainer.BackgroundTransparency = 1
                centerContainer.Parent = gui

                -- Glowing background effect
                local glowFrame = Instance.new("Frame")
                glowFrame.Name = "GlowFrame"
                glowFrame.AnchorPoint = Vector2.new(0.5, 0.5)
                glowFrame.Position = UDim2.fromScale(0.5, 0.5)
                glowFrame.Size = UDim2.fromScale(1.1, 1.1)
                glowFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 100)
                glowFrame.BackgroundTransparency = 0.7
                glowFrame.BorderSizePixel = 0
                glowFrame.Parent = centerContainer

                local glowCorner = Instance.new("UICorner")
                glowCorner.CornerRadius = UDim.new(0, 20)
                glowCorner.Parent = glowFrame

                -- Glow pulsing animation
                task.spawn(function()
                    while glowFrame.Parent do
                        TweenService:Create(glowFrame, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            BackgroundTransparency = 0.4,
                            Size = UDim2.fromScale(1.15, 1.15)
                        }):Play()
                        task.wait(0.8)
                        TweenService:Create(glowFrame, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            BackgroundTransparency = 0.8,
                            Size = UDim2.fromScale(1.05, 1.05)
                        }):Play()
                        task.wait(0.8)
                    end
                end)

                -- Main warning text
                local warnText = Instance.new("TextLabel")
                warnText.Name = "WarnText"
                warnText.AnchorPoint = Vector2.new(0.5, 0.5)
                warnText.Position = UDim2.fromScale(0.5, 0.5)
                warnText.Size = UDim2.fromScale(0.95, 0.5)
                warnText.BackgroundTransparency = 1
                warnText.Text = isMassInfection and "MASS INFECTION WARN" or "ENTANGLEMENT WARN"
                warnText.Font = Enum.Font.GothamBlack
                warnText.TextScaled = true
                warnText.TextColor3 = Color3.fromRGB(255, 255, 255)
                warnText.TextStrokeTransparency = 0
                warnText.TextStrokeColor3 = Color3.fromRGB(255, 0, 100)
                warnText.Parent = centerContainer

                -- Text gradient effect
                local textGradient = Instance.new("UIGradient")
                textGradient.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 100)),
                    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 255, 255)),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
                }
                textGradient.Parent = warnText

                -- Animate text gradient
                task.spawn(function()
                    local offset = 0
                    while warnText.Parent do
                        offset = (offset + 0.015) % 1
                        textGradient.Offset = Vector2.new(offset, 0)
                        task.wait(0.03)
                    end
                end)

                -- Glitch effect on text
                task.spawn(function()
                    local originalPos = warnText.Position
                    while warnText.Parent do
                        -- Random glitch
                        if math.random() > 0.85 then
                            local offsetX = (math.random() - 0.5) * 0.02
                            local offsetY = (math.random() - 0.5) * 0.02
                            warnText.Position = UDim2.new(
                                originalPos.X.Scale + offsetX,
                                originalPos.X.Offset,
                                originalPos.Y.Scale + offsetY,
                                originalPos.Y.Offset
                            )
                            task.wait(0.05)
                            warnText.Position = originalPos
                        end
                        task.wait(0.1)
                    end
                end)

                -- Glitch effect bars (top and bottom of warning box only)
                local function createGlitchBar(yPos)
                    local bar = Instance.new("Frame")
                    bar.Size = UDim2.new(1, 0, 0, 3)
                    bar.Position = UDim2.fromScale(0, yPos)
                    bar.BackgroundColor3 = Color3.fromRGB(255, 0, 100)
                    bar.BorderSizePixel = 0
                    bar.Parent = centerContainer

                    local barGradient = Instance.new("UIGradient")
                    barGradient.Color = ColorSequence.new{
                        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 100)),
                        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)),
                        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 100))
                    }
                    barGradient.Parent = bar

                    -- Animate gradient offset
                    task.spawn(function()
                        local offset = 0
                        while bar.Parent do
                            offset = (offset + 0.02) % 1
                            barGradient.Offset = Vector2.new(offset, 0)
                            task.wait(0.03)
                        end
                    end)

                    return bar
                end

                local topBar = createGlitchBar(0)
                local bottomBar = createGlitchBar(1)

                -- Pulsing bars animation
                task.spawn(function()
                    while gui.Parent do
                        TweenService:Create(topBar, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            Size = UDim2.new(1, 0, 0, 6)
                        }):Play()
                        TweenService:Create(bottomBar, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            Size = UDim2.new(1, 0, 0, 6)
                        }):Play()
                        task.wait(0.6)
                        TweenService:Create(topBar, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            Size = UDim2.new(1, 0, 0, 3)
                        }):Play()
                        TweenService:Create(bottomBar, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                            Size = UDim2.new(1, 0, 0, 3)
                        }):Play()
                        task.wait(0.6)
                    end
                end)

                -- Entrance animation
                centerContainer.Size = UDim2.fromScale(0, 0)
                TweenService:Create(centerContainer, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                    Size = UDim2.fromScale(0.6, 0.15)
                }):Play()

                warnGui = gui
            end
            
            local function destroyWarningGui()
                if warnGui and warnGui.Parent then
                    warnGui:Destroy()
                    warnGui = nil
                end
            end
            
            local function isLocalPlayerInside(part)
                if not LocalPlayer or not LocalPlayer.Character then return false end
                if not part or not part.Parent then return false end
                
                -- ÂàõÂª∫Êõ¥Á≤æÁ°ÆÁöÑÊ£ÄÊµãÁÇπÔºàÂæÄÂõûÂÅèÁßª 0.5 studÔºâ
                local partSize = part.Size
                local detectionPart = Instance.new("Part")
                detectionPart.Size = Vector3.new(0.1, 0.1, 0.1) -- Â∞èÊ£ÄÊµãÁÇπ
                detectionPart.CanCollide = false
                detectionPart.Transparency = 1
                
                -- ËÆ°ÁÆóÊ£ÄÊµãÁÇπ‰ΩçÁΩÆÔºöÂú®ÊñπÂùó‰∏≠ÂøÉÂæÄÂõû 0.5 stud
                local backDir = -part.CFrame.LookVector
                local detectionPos = part.CFrame.Position + backDir * 0.5
                detectionPart.CFrame = CFrame.new(detectionPos)
                detectionPart.Parent = workspace
                
                local isInside = false
                local touchingParts = workspace:GetPartsInPart(detectionPart)
                for _, p in ipairs(touchingParts) do
                    if p:IsDescendantOf(LocalPlayer.Character) then
                        isInside = true
                        break
                    end
                end
                
                detectionPart:Destroy()
                return isInside
            end
            -- Track static block state (Shockwave for Mass Infection, Swords for Entanglement)
            local staticBlockDetected = false
            local staticBlockDirection = nil
            local staticBlock = nil
            local staticBlockDetectedTime = 0
            local staticBlockFreezeDuration = 5.5
            
            -- Monitor for static block spawn (Shockwave or Swords)
            local staticBlockConnection
            local function checkForStaticBlock()
                local mapPath = workspace:FindFirstChild("Map")
                if mapPath then
                    local ingame = mapPath:FindFirstChild("Ingame")
                    if ingame then
                        -- Check for Mass Infection's Shockwave or Entanglement's Swords
                        local staticObject = nil
                        local objectName = ""
                        
                        if isMassInfection then
                            -- Check for both "Shockwave" and "shockwave"
                            staticObject = ingame:FindFirstChild("Shockwave") or ingame:FindFirstChild("shockwave")
                            objectName = "SHOCKWAVE"
                        else -- Entanglement
                            staticObject = ingame:FindFirstChild("Swords")
                            objectName = "SWORDS"
                        end
                        
                        if staticObject and not staticBlockDetected then
                            staticBlockDetected = true
                            staticBlockDetectedTime = os.clock()
                            print("üîç " .. objectName .. " FOUND! Object type:", staticObject.ClassName)
                            
                            -- Find the part in the object (Model or BasePart)
                            local objectPart = nil
                            if staticObject:IsA("Model") then
                                -- For Swords Model, specifically look for "Core" part
                                if not isMassInfection then
                                    objectPart = staticObject:FindFirstChild("Core")
                                    if objectPart then
                                        print("  ‚úì Found Swords.Core part!")
                                    else
                                        print("  ‚ö†Ô∏è Swords.Core not found, trying fallback...")
                                        objectPart = staticObject.PrimaryPart or staticObject:FindFirstChildWhichIsA("BasePart")
                                    end
                                else
                                    objectPart = staticObject.PrimaryPart or staticObject:FindFirstChildWhichIsA("BasePart")
                                end
                                print("  " .. objectName .. " is a Model, using part:", objectPart and objectPart.Name or "nil")
                            elseif staticObject:IsA("BasePart") then
                                objectPart = staticObject
                                print("  " .. objectName .. " is a BasePart")
                            end
                            
                            if not objectPart then
                                print("  ‚ö†Ô∏è Could not find a part in " .. objectName .. " model")
                                staticBlockDetected = false -- Reset so it can try again
                                return
                            end
                            
                            if isMassInfection then
                                -- Mass Infection: Destroy lookvector blocks and replace with static block
                                print("üåä SHOCKWAVE DETECTED! Destroying lookvector blocks and creating static block...")
                                
                                if shortBlock and shortBlock.Parent then
                                    shortBlock:Destroy()
                                    print("‚úì Destroyed SHORT lookvector block")
                                end
                                if longBlock and longBlock.Parent then
                                    longBlock:Destroy()
                                    print("‚úì Destroyed LONG lookvector block")
                                end
                                
                                -- Get velocity direction for static block
                                local velocity = objectPart.AssemblyLinearVelocity
                                if velocity.Magnitude > 0.1 then
                                    staticBlockDirection = Vector3.new(velocity.X, 0, velocity.Z).Unit
                                    print("  Using " .. objectName .. " velocity direction:", staticBlockDirection)
                                else
                                    staticBlockDirection = Vector3.new(objectPart.CFrame.LookVector.X, 0, objectPart.CFrame.LookVector.Z).Unit
                                    print("  Using " .. objectName .. " CFrame direction (fallback):", staticBlockDirection)
                                end
                                
                                -- Create static tracking block
                                if character then
                                    local killerRoot = character:FindFirstChild("HumanoidRootPart")
                                    if killerRoot then
                                        staticBlock = Instance.new("Part")
                                        staticBlock.Name = objectName .. "TrackingBlock"
                                        staticBlock.Size = longSize -- Use the same size as longBlock
                                        staticBlock.Anchored = true
                                        staticBlock.CanCollide = false
                                        staticBlock.Material = Enum.Material.ForceField
                                        staticBlock.Color = Color3.fromRGB(0, 255, 255) -- Cyan color
                                        staticBlock.Transparency = 0.5
                                        
                                        local rootPos = killerRoot.Position
                                        local blockPos = rootPos + staticBlockDirection * (staticBlock.Size.Z / 2)
                                        staticBlock.CFrame = CFrame.new(blockPos, blockPos + staticBlockDirection)
                                        staticBlock.Parent = workspace
                                        
                                        print("‚úì Created " .. objectName .. " static tracking block")
                                        Debris:AddItem(staticBlock, 10)
                                    end
                                end
                            else
                                -- Entanglement (Swords): Create static block with EXACT CFrame matching Swords
                                print("‚öîÔ∏è SWORDS DETECTED! Creating static block matching Swords CFrame exactly...")
                                
                                -- Destroy red lookvector blocks when Swords appear
                                if shortBlock and shortBlock.Parent then
                                    shortBlock:Destroy()
                                    print("‚úì Destroyed SHORT lookvector block")
                                end
                                if longBlock and longBlock.Parent then
                                    longBlock:Destroy()
                                    print("‚úì Destroyed LONG lookvector block")
                                end
                                
                                staticBlock = Instance.new("Part")
                                staticBlock.Name = objectName .. "TrackingBlock"
                                staticBlock.Size = longSize -- Use the same size as longBlock
                                staticBlock.Anchored = true
                                staticBlock.CanCollide = false
                                staticBlock.Material = Enum.Material.ForceField
                                staticBlock.Color = Color3.fromRGB(0, 255, 255) -- Cyan color
                                staticBlock.Transparency = 0.5
                                
                                -- Copy EXACT CFrame from Swords.Core (position + rotation + orientation)
                                staticBlock.CFrame = objectPart.CFrame
                                staticBlock.Parent = workspace
                                
                                print("‚úì Created static block matching Swords CFrame exactly")
                                print("  Position:", objectPart.Position)
                                print("  LookVector:", objectPart.CFrame.LookVector)
                                Debris:AddItem(staticBlock, 10)
                            end
                        end
                    end
                end
            end
            
            -- Update loop: rotate blocks to face killer's look direction and manage warning GUI
            local blockUpdateConnection
            blockUpdateConnection = RunService.Heartbeat:Connect(function()
                -- Check for static block spawn
                checkForStaticBlock()
                
                -- Process static block if detected (for both Mass Infection and Entanglement)
                if staticBlockDetected then
                    if staticBlock and staticBlock.Parent then
                        -- Check if player is inside static block
                        local isInsideNow = isLocalPlayerInside(staticBlock)
                        
                        if isInsideNow then
                            -- Player is inside static block
                            createWarningGui()
                            
                            -- Keep playing sound while inside
                            if not soundPlaying then
                                sound:Play()
                                soundPlaying = true
                                lastPlayed = os.clock()
                            else
                                -- Restart sound every 1 second to keep alert active
                                local now = os.clock()
                                if now - lastPlayed >= 1 then
                                    sound:Stop()
                                    sound:Play()
                                    lastPlayed = now
                                end
                            end
                        else
                            -- Player is outside static block
                            destroyWarningGui()
                            if sound and sound.Parent then
                                sound:Stop()
                                soundPlaying = false
                            end
                        end
                        
                        -- Check if static block duration has expired
                        local elapsedTime = os.clock() - staticBlockDetectedTime
                        if elapsedTime >= staticBlockFreezeDuration then
                            print("‚è∞ Static block ended (5.5s), destroying block")
                            if staticBlock and staticBlock.Parent then
                                staticBlock:Destroy()
                            end
                            destroyWarningGui()
                            if sound and sound.Parent then
                                sound:Stop()
                                soundPlaying = false
                            end
                            if blockUpdateConnection then
                                blockUpdateConnection:Disconnect()
                            end
                            return
                        end
                    else
                        -- Static block destroyed, cleanup
                        destroyWarningGui()
                        if sound and sound.Parent then
                            sound:Stop()
                            soundPlaying = false
                        end
                        if blockUpdateConnection then
                            blockUpdateConnection:Disconnect()
                        end
                        return
                    end
                    -- If Mass Infection, don't process lookvector blocks when static block is active
                    if isMassInfection then
                        return
                    end
                end
                
                -- Normal lookvector block logic (always for Entanglement, or Mass Infection before static block)
                if not longBlock or not longBlock.Parent or not running then 
                    if blockUpdateConnection then
                        blockUpdateConnection:Disconnect()
                    end
                    if staticBlockConnection then
                        staticBlockConnection:Disconnect()
                    end
                    destroyWarningGui()
                    if sound and sound.Parent then
                        sound:Stop()
                        soundPlaying = false
                    end
                    return 
                end
                
                -- Move and rotate blocks based on killer's look direction
                if character then
                    local killerRoot = character:FindFirstChild("HumanoidRootPart")
                    if killerRoot then
                        local killerLook = killerRoot.CFrame.LookVector
                        local directionToUse = Vector3.new(killerLook.X, 0, killerLook.Z).Unit
                        
                        -- Calculate new positions based on killer's current position
                        local rootPos = killerRoot.Position
                        local shortPos = rootPos + directionToUse * (shortBlock.Size.Z / 2)
                        local longPos = rootPos + directionToUse * (longBlock.Size.Z / 2)
                        
                        -- Update CFrames to new positions and face the direction
                        shortBlock.CFrame = CFrame.new(shortPos, shortPos + directionToUse)
                        longBlock.CFrame = CFrame.new(longPos, longPos + directionToUse)
                    end
                end
                
                -- Check if player is inside lookvector blocks
                local insideNow = isLocalPlayerInside(longBlock) or isLocalPlayerInside(shortBlock)
                
                -- For Entanglement, also check static block if it exists
                if not isMassInfection and staticBlock and staticBlock.Parent then
                    insideNow = insideNow or isLocalPlayerInside(staticBlock)
                end
                
                if insideNow then
                    -- Player is inside lookvector blocks
                    createWarningGui()
                    
                    -- Keep playing sound while inside
                    if not soundPlaying then
                        sound:Play()
                        soundPlaying = true
                        lastPlayed = os.clock()
                    else
                        -- Restart sound every 1 second to keep alert active
                        local now = os.clock()
                        if now - lastPlayed >= 1 then
                            sound:Stop()
                            sound:Play()
                            lastPlayed = now
                        end
                    end
                else
                    -- Player is outside lookvector blocks
                    if soundPlaying then
                        sound:Stop()
                        soundPlaying = false
                    end
                    destroyWarningGui()
                end
            end)
        end
    end
end

-- Function to set up listeners for a specific character model
local function setupCharacter(character)
    if not running then return end
    
    -- ONLY monitor the target character
    if character.Name ~= TARGET_KILLER_NAME then
        debugPrint("Skipping non-target character:", character.Name)
        return
    end
    
    if monitoredCharacters[character] then 
        debugPrint("Character already monitored:", character.Name)
        return 
    end
    monitoredCharacters[character] = true
    
    print("‚úì Setting up TARGET character:", character.Name)
    debugPrint("  Full path:", character:GetFullName())
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then 
        debugPrint("  No Humanoid found in character")
        return 
    end
    debugPrint("  Humanoid found:", humanoid)
    
    -- Create animation handler for this specific character
    local onAnimationPlayed = createAnimationHandler(character)
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        debugPrint("  No Animator found, waiting for it...")
        -- If animator doesn't exist, wait for it
        local animConnection
        animConnection = humanoid.ChildAdded:Connect(function(child)
            if child:IsA("Animator") then
                debugPrint("  Animator added:", child)
                table.insert(connections, child.AnimationPlayed:Connect(onAnimationPlayed))
                animConnection:Disconnect()
                -- Also check any currently playing tracks right away
                local playingTracks = child:GetPlayingAnimationTracks()
                debugPrint("  Currently playing tracks:", #playingTracks)
                for _, track in ipairs(playingTracks) do
                    onAnimationPlayed(track)
                end
            end
        end)
        table.insert(connections, animConnection)
    else
        debugPrint("  Animator found:", animator)
        table.insert(connections, animator.AnimationPlayed:Connect(onAnimationPlayed))
        -- Fire for tracks already playing
        local playingTracks = animator:GetPlayingAnimationTracks()
        debugPrint("  Currently playing tracks:", #playingTracks)
        for i, track in ipairs(playingTracks) do
            debugPrint("    Track", i, ":", track.Animation.AnimationId)
            onAnimationPlayed(track)
        end
    end
    
    print("‚úì Now monitoring animations for:", character.Name)
end

-- Main function to find the killer and connect events
local function main()
    print("========================================")
    print("Animation Detection Script Starting")
    print("Target Killer:", TARGET_KILLER_NAME)
    print("Press P to toggle script on/off")
    print("Detecting Mass Infection Animations:", getKeysString(MASS_INFECTION_IDS))
    print("Detecting Entanglement Animations:", getKeysString(ENTANGLEMENT_IDS))
    print("========================================")
    
    -- Preferred path: workspace.Players.Killers
    local killersFolder = workspace:FindFirstChild("Players")
    if killersFolder then
        killersFolder = killersFolder:FindFirstChild("Killers")
    end

    -- Check preferred path first
    if killersFolder then
        print("‚úì Found killers folder at: workspace.Players.Killers")
        local childCount = #killersFolder:GetChildren()
        print("  Found", childCount, "children in Killers folder")
        
        -- Look specifically for 1x1x1x1
        local target = killersFolder:FindFirstChild(TARGET_KILLER_NAME)
        if target then
            print("‚úì FOUND TARGET:", TARGET_KILLER_NAME)
            debugPrint("  Full path:", target:GetFullName())
            local humanoid = target:FindFirstChild("Humanoid")
            debugPrint("  Has Humanoid:", humanoid ~= nil)
            if humanoid then
                local animator = humanoid:FindFirstChild("Animator") or humanoid:FindFirstChildOfClass("Animator")
                debugPrint("  Has Animator:", animator ~= nil)
                if animator then
                    local tracks = animator:GetPlayingAnimationTracks()
                    print("  Currently playing", #tracks, "animation(s)")
                    for i, track in ipairs(tracks) do
                        print("    Animation", i, ":", track.Animation.AnimationId)
                    end
                end
            end
        else
            warn("‚úó Could not find", TARGET_KILLER_NAME, "in Killers folder!")
            print("  Available children:")
            for _, child in ipairs(killersFolder:GetChildren()) do
                print("    -", child.Name, "(" .. child.ClassName .. ")")
            end
        end
        
        -- ONLY monitor the target model
        local targetModel = killersFolder:FindFirstChild(TARGET_KILLER_NAME)
        if targetModel and targetModel:IsA("Model") and targetModel:FindFirstChildOfClass("Humanoid") then
            setupCharacter(targetModel)
        end
        
        -- Watch for the target model being added (if not already present)
        table.insert(connections, killersFolder.ChildAdded:Connect(function(child)
            if child.Name == TARGET_KILLER_NAME and child:IsA("Model") and child:FindFirstChildOfClass("Humanoid") then
                print("‚úì Target model", TARGET_KILLER_NAME, "was added to Killers folder")
                setupCharacter(child)
            end
        end))
    else
        warn("‚úó Could not find folder at path: workspace.Players.Killers")
        print("‚úó Script will not work without the Killers folder!")
        return
    end
    
    -- Listen for toggle key
    table.insert(connections, UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == SHUTDOWN_KEY then
            if running then
                shutdown()
                print("Script toggled OFF")
            else
                print("Script is already off. Re-execute to restart.")
            end
        end
    end))
    
    print("Animation detection script is running. Press P to toggle off.")
end

-- Run the script
main()

-- Mark script as fully loaded
_G.masssword = true

-- Monitor _G.masssword status every second
task.spawn(function()
    while running do
        task.wait(1)
        if _G.masssword == false then
            if not paused then
                paused = true
                print("‚è∏Ô∏è Script PAUSED: _G.masssword is false")
            end
        else
            if paused then
                paused = false
                print("‚ñ∂Ô∏è Script RESUMED: _G.masssword is true")
            end
        end
    end
end)
